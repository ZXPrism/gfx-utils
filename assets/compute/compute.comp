// NOTE: Based on GPT (since I don't know how to generate fractals)

#version 460 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(std430, binding = 0) buffer InputBuffer {
    vec4 data[];
};

uniform int window_width;
uniform int window_height;
uniform float time; // time in seconds, updated each frame

const int max_iterations = 300;
const float zoom = 1.5;

// HSV -> RGB conversion
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if(x >= window_width || y >= window_height)
        return;

    uint idx = y * window_width + x;

    // Animated Julia constant
    vec2 c = vec2(0.7885 * cos(time), 0.7885 * sin(time));

    // Map pixel to complex plane
    float fx = (float(x) / float(window_width) - 0.5) * 2.0 * zoom;
    float fy = (float(y) / float(window_height) - 0.5) * 2.0 * zoom * float(window_height) / float(window_width);
    vec2 z = vec2(fx, fy);

    int i;
    for(i = 0; i < max_iterations; i++) {
        float x2 = z.x * z.x - z.y * z.y + c.x;
        float y2 = 2.0 * z.x * z.y + c.y;
        z = vec2(x2, y2);
        if(dot(z, z) > 4.0)
            break;
    }

    // Subtle grid overlay
    float gx = mod(float(x), 16.0) / 16.0;
    float gy = mod(float(y), 16.0) / 16.0;
    float grid = step(0.05, gx) * step(0.05, gy);

    // Map iteration count to HSV color
    float t = float(i) / float(max_iterations);
    vec3 hsv = vec3(0.7 + 0.5 * t, 0.8, 0.9 * grid + 0.1);
    vec3 rgb = hsv2rgb(hsv);

    data[idx] = vec4(rgb, 1.0);
}
